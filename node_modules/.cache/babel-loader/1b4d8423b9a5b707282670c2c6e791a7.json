{"ast":null,"code":"import { useCallback, useEffect, useRef, useState } from 'react';\nimport useDebouncedCallback from './useDebouncedCallback';\n\nfunction valueEquality(left, right) {\n  return left === right;\n}\n\nexport default function useDebounce(value, delay, options) {\n  var eq = options && options.equalityFn ? options.equalityFn : valueEquality;\n\n  var _a = useState(value),\n      state = _a[0],\n      dispatch = _a[1];\n\n  var _b = useDebouncedCallback(useCallback(function (value) {\n    return dispatch(value);\n  }, []), delay, options),\n      callback = _b[0],\n      cancel = _b[1],\n      callPending = _b[2];\n\n  var previousValue = useRef(value);\n  useEffect(function () {\n    // We need to use this condition otherwise we will run debounce timer for the first render (including maxWait option)\n    if (!eq(previousValue.current, value)) {\n      callback(value);\n      previousValue.current = value;\n    }\n  }, [value, callback, eq]);\n  return [state, cancel, callPending];\n}","map":{"version":3,"sources":["/home/gzamora/Documents/test/react-ultimate-resume/node_modules/use-debounce/esm/useDebounce.js"],"names":["useCallback","useEffect","useRef","useState","useDebouncedCallback","valueEquality","left","right","useDebounce","value","delay","options","eq","equalityFn","_a","state","dispatch","_b","callback","cancel","callPending","previousValue","current"],"mappings":"AAAA,SAASA,WAAT,EAAsBC,SAAtB,EAAiCC,MAAjC,EAAyCC,QAAzC,QAAyD,OAAzD;AACA,OAAOC,oBAAP,MAAiC,wBAAjC;;AACA,SAASC,aAAT,CAAuBC,IAAvB,EAA6BC,KAA7B,EAAoC;AAChC,SAAOD,IAAI,KAAKC,KAAhB;AACH;;AACD,eAAe,SAASC,WAAT,CAAqBC,KAArB,EAA4BC,KAA5B,EAAmCC,OAAnC,EAA4C;AACvD,MAAIC,EAAE,GAAGD,OAAO,IAAIA,OAAO,CAACE,UAAnB,GAAgCF,OAAO,CAACE,UAAxC,GAAqDR,aAA9D;;AACA,MAAIS,EAAE,GAAGX,QAAQ,CAACM,KAAD,CAAjB;AAAA,MAA0BM,KAAK,GAAGD,EAAE,CAAC,CAAD,CAApC;AAAA,MAAyCE,QAAQ,GAAGF,EAAE,CAAC,CAAD,CAAtD;;AACA,MAAIG,EAAE,GAAGb,oBAAoB,CAACJ,WAAW,CAAC,UAAUS,KAAV,EAAiB;AAAE,WAAOO,QAAQ,CAACP,KAAD,CAAf;AAAyB,GAA7C,EAA+C,EAA/C,CAAZ,EAAgEC,KAAhE,EAAuEC,OAAvE,CAA7B;AAAA,MAA8GO,QAAQ,GAAGD,EAAE,CAAC,CAAD,CAA3H;AAAA,MAAgIE,MAAM,GAAGF,EAAE,CAAC,CAAD,CAA3I;AAAA,MAAgJG,WAAW,GAAGH,EAAE,CAAC,CAAD,CAAhK;;AACA,MAAII,aAAa,GAAGnB,MAAM,CAACO,KAAD,CAA1B;AACAR,EAAAA,SAAS,CAAC,YAAY;AAClB;AACA,QAAI,CAACW,EAAE,CAACS,aAAa,CAACC,OAAf,EAAwBb,KAAxB,CAAP,EAAuC;AACnCS,MAAAA,QAAQ,CAACT,KAAD,CAAR;AACAY,MAAAA,aAAa,CAACC,OAAd,GAAwBb,KAAxB;AACH;AACJ,GANQ,EAMN,CAACA,KAAD,EAAQS,QAAR,EAAkBN,EAAlB,CANM,CAAT;AAOA,SAAO,CAACG,KAAD,EAAQI,MAAR,EAAgBC,WAAhB,CAAP;AACH","sourcesContent":["import { useCallback, useEffect, useRef, useState } from 'react';\nimport useDebouncedCallback from './useDebouncedCallback';\nfunction valueEquality(left, right) {\n    return left === right;\n}\nexport default function useDebounce(value, delay, options) {\n    var eq = options && options.equalityFn ? options.equalityFn : valueEquality;\n    var _a = useState(value), state = _a[0], dispatch = _a[1];\n    var _b = useDebouncedCallback(useCallback(function (value) { return dispatch(value); }, []), delay, options), callback = _b[0], cancel = _b[1], callPending = _b[2];\n    var previousValue = useRef(value);\n    useEffect(function () {\n        // We need to use this condition otherwise we will run debounce timer for the first render (including maxWait option)\n        if (!eq(previousValue.current, value)) {\n            callback(value);\n            previousValue.current = value;\n        }\n    }, [value, callback, eq]);\n    return [state, cancel, callPending];\n}\n"]},"metadata":{},"sourceType":"module"}