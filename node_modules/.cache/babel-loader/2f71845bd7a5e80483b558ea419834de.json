{"ast":null,"code":"import { useRef, useCallback, useEffect } from 'react';\nexport default function useDebouncedCallback(callback, delay, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var maxWait = options.maxWait;\n  var maxWaitHandler = useRef(null);\n  var maxWaitArgs = useRef([]);\n  var leading = options.leading;\n  var trailing = options.trailing === undefined ? true : options.trailing;\n  var leadingCall = useRef(false);\n  var functionTimeoutHandler = useRef(null);\n  var isComponentUnmounted = useRef(false);\n  var debouncedFunction = useRef(callback);\n  debouncedFunction.current = callback;\n  var cancelDebouncedCallback = useCallback(function () {\n    clearTimeout(functionTimeoutHandler.current);\n    clearTimeout(maxWaitHandler.current);\n    maxWaitHandler.current = null;\n    maxWaitArgs.current = [];\n    functionTimeoutHandler.current = null;\n    leadingCall.current = false;\n  }, []);\n  useEffect(function () {\n    // We have to set isComponentUnmounted to be truth, as fast-refresh runs all useEffects\n    isComponentUnmounted.current = false;\n    return function () {\n      // we use flag, as we allow to call callPending outside the hook\n      isComponentUnmounted.current = true;\n    };\n  }, []);\n  var debouncedCallback = useCallback(function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    maxWaitArgs.current = args;\n    clearTimeout(functionTimeoutHandler.current);\n\n    if (leadingCall.current) {\n      leadingCall.current = false;\n    }\n\n    if (!functionTimeoutHandler.current && leading && !leadingCall.current) {\n      debouncedFunction.current.apply(debouncedFunction, args);\n      leadingCall.current = true;\n    }\n\n    functionTimeoutHandler.current = setTimeout(function () {\n      var shouldCallFunction = true;\n\n      if (leading && leadingCall.current) {\n        shouldCallFunction = false;\n      }\n\n      cancelDebouncedCallback();\n\n      if (!isComponentUnmounted.current && trailing && shouldCallFunction) {\n        debouncedFunction.current.apply(debouncedFunction, args);\n      }\n    }, delay);\n\n    if (maxWait && !maxWaitHandler.current && trailing) {\n      maxWaitHandler.current = setTimeout(function () {\n        var args = maxWaitArgs.current;\n        cancelDebouncedCallback();\n\n        if (!isComponentUnmounted.current) {\n          debouncedFunction.current.apply(null, args);\n        }\n      }, maxWait);\n    }\n  }, [maxWait, delay, cancelDebouncedCallback, leading, trailing]);\n  var callPending = useCallback(function () {\n    // Call pending callback only if we have anything in our queue\n    if (!functionTimeoutHandler.current) {\n      return;\n    }\n\n    debouncedFunction.current.apply(null, maxWaitArgs.current);\n    cancelDebouncedCallback();\n  }, [cancelDebouncedCallback]); // At the moment, we use 3 args array so that we save backward compatibility\n\n  return [debouncedCallback, cancelDebouncedCallback, callPending];\n}","map":{"version":3,"sources":["/home/gzamora/Documents/test/react-ultimate-resume/node_modules/use-debounce/esm/useDebouncedCallback.js"],"names":["useRef","useCallback","useEffect","useDebouncedCallback","callback","delay","options","maxWait","maxWaitHandler","maxWaitArgs","leading","trailing","undefined","leadingCall","functionTimeoutHandler","isComponentUnmounted","debouncedFunction","current","cancelDebouncedCallback","clearTimeout","debouncedCallback","args","_i","arguments","length","apply","setTimeout","shouldCallFunction","callPending"],"mappings":"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","sourcesContent":["import { useRef, useCallback, useEffect } from 'react';\nexport default function useDebouncedCallback(callback, delay, options) {\n    if (options === void 0) { options = {}; }\n    var maxWait = options.maxWait;\n    var maxWaitHandler = useRef(null);\n    var maxWaitArgs = useRef([]);\n    var leading = options.leading;\n    var trailing = options.trailing === undefined ? true : options.trailing;\n    var leadingCall = useRef(false);\n    var functionTimeoutHandler = useRef(null);\n    var isComponentUnmounted = useRef(false);\n    var debouncedFunction = useRef(callback);\n    debouncedFunction.current = callback;\n    var cancelDebouncedCallback = useCallback(function () {\n        clearTimeout(functionTimeoutHandler.current);\n        clearTimeout(maxWaitHandler.current);\n        maxWaitHandler.current = null;\n        maxWaitArgs.current = [];\n        functionTimeoutHandler.current = null;\n        leadingCall.current = false;\n    }, []);\n    useEffect(function () {\n        // We have to set isComponentUnmounted to be truth, as fast-refresh runs all useEffects\n        isComponentUnmounted.current = false;\n        return function () {\n            // we use flag, as we allow to call callPending outside the hook\n            isComponentUnmounted.current = true;\n        };\n    }, []);\n    var debouncedCallback = useCallback(function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        maxWaitArgs.current = args;\n        clearTimeout(functionTimeoutHandler.current);\n        if (leadingCall.current) {\n            leadingCall.current = false;\n        }\n        if (!functionTimeoutHandler.current && leading && !leadingCall.current) {\n            debouncedFunction.current.apply(debouncedFunction, args);\n            leadingCall.current = true;\n        }\n        functionTimeoutHandler.current = setTimeout(function () {\n            var shouldCallFunction = true;\n            if (leading && leadingCall.current) {\n                shouldCallFunction = false;\n            }\n            cancelDebouncedCallback();\n            if (!isComponentUnmounted.current && trailing && shouldCallFunction) {\n                debouncedFunction.current.apply(debouncedFunction, args);\n            }\n        }, delay);\n        if (maxWait && !maxWaitHandler.current && trailing) {\n            maxWaitHandler.current = setTimeout(function () {\n                var args = maxWaitArgs.current;\n                cancelDebouncedCallback();\n                if (!isComponentUnmounted.current) {\n                    debouncedFunction.current.apply(null, args);\n                }\n            }, maxWait);\n        }\n    }, [maxWait, delay, cancelDebouncedCallback, leading, trailing]);\n    var callPending = useCallback(function () {\n        // Call pending callback only if we have anything in our queue\n        if (!functionTimeoutHandler.current) {\n            return;\n        }\n        debouncedFunction.current.apply(null, maxWaitArgs.current);\n        cancelDebouncedCallback();\n    }, [cancelDebouncedCallback]);\n    // At the moment, we use 3 args array so that we save backward compatibility\n    return [debouncedCallback, cancelDebouncedCallback, callPending];\n}\n"]},"metadata":{},"sourceType":"module"}